---
title: "Engineers Must Own Quality"
date: 2023-04-08T19:32:20-07:00
draft: false

description: "Looking to improve the quality of the code you write? Learn why engineers should take ownership of code quality, and how to do it effectively. Discover why quality and assurance teams may not be enough, and how to push for sustainable quality in a changing software landscape. Read on for insights into the importance of great code, and the lifecycle of software beyond the build stage."

tags:
- code quality
- software engineering
- quality assurance
- sustainable development
- software lifecycle

categories:
- software development
- engineering practices
- quality management
- project management
- software architecture
---

# Why Quality & Assurance Teams are Not Enough: Engineers Must Take Responsibility

Engineers must own the quality of the code that they write. Typical quality & assurance teams do not reinforce correct ownership. 

As engineers, our job is to push for quality. We're the only ones that are close enough to the code to understand the shortcuts we're taking, what problems we're creating for the future, and what issues may happen down the road as a result of our actions.

We are the ones that live with the decisions we make down the road. And we get to feel the joy and the pain of those decisions. Whether it's things finally working after a long day, a customer being delighted by a new feature, a flaky test, a bug, or an architectural problem. We feel and endure the entire spectrum of emotions. So it is our job to push for quality in a way that is sustainable.

And it's fine if people push in different directions at times. It is completely natural for different perspectives to seek out different directions. For example, product management will always advocate for the business: they know what will move the needle and they know what customers want. Because they are obsessed about our customers and all the metrics surrounding them in a way that engineers often don't see.

As engineers, we have to recognize that great code is not enough. Even though great code creates the pillars of our foundation, it requires refinement. Businesses change, customers ask for new things, and requirements evolve. Time passes.

The lifecycle of software does not stop after building. We refine, develop new ideas, and promote them.